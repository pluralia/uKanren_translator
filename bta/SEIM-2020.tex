\documentclass[conference,american,russian]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{listings}
\usepackage{tikz}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\renewcommand{\sfdefault}{cmss}
\renewcommand{\rmdefault}{cmr}
\renewcommand{\ttdefault}{cmt}

\def\IEEEkeywordsname{Ключевые понятия}

\newcommand{\miniKanren}{\textsc{miniKanren}}
\newcommand{\mercury}{\textsc{Mercury}}
\newcommand{\haskell}{\textsc{Haskell}}
\newcommand{\prolog}{\textsc{Prolog}}
\newcommand{\scheme}{\textsc{Scheme}}

\newcommand{\github}{\textsc{GitHub}}

\lstset{mathescape=true}

\title{Анализ времени связывания для реляционных программ}

\author{\IEEEauthorblockN{Ирина Артемьева}
\IEEEauthorblockA{\textit{Университет ИТМО} \\
Санкт-Перебург, Россия \\
irinapluralia@gmail.com}
\and
\IEEEauthorblockN{Екатерина Вербицкая}
\textit{JetBrains Research}\\
Санкт-Перебург, Россия \\
kajigor@gmail.com}


\maketitle

\begin{abstract}
Программы в парадигме реляционного программирования представляют собой математические отношения.
Программы-отношения можно исполнять в различных направлениях: зафиксировав часть аргументов программы, находить значение остальных.
Не всегда исполнение программы в заданном направлении эффективно. 
Одним из способов улучшения производительности является трансляция реляционных программ в функциональные. 
Для генерации функции по отношению необходимо определить порядок связывания имен в программе с учетом заданного направления.
Для этого традиционно применяется анализ времени связывания, однако для реляционных языков ранее его разработано не было.
В статье мы предлагаем алгоритм анализа времени связывания для языка реляционного программирования \miniKanren{}. 
\end{abstract}

\begin{IEEEkeywords}
Реляционное программирование, анализ времени связывания, статический анализ
\end{IEEEkeywords}

\section{Введение}

Реляционное программирование --- парадигма, в которой любая программа описывает математическое отношение на ее аргументах. 
Имея программу-отношение, можно выполнять запросы: указывая некоторые известные аргументы, получать значения остальных.
Например, $add^o \subseteq Int \times Int \times Int$ описывает отношение, третий аргумент которого является суммой первых двух. 
Рассмотрим возможные направления вычисления этого отношения (здесь и далее входной аргумент будем обозначать $?$).
Выполнение отношения $add^o  \ x \ y \ ?$ с зафиксированными (выходными) первым и вторым аргументом найдет их сумму, а $add^o \ ? \ y \ z$ найдет такие числа, которые в сумме с $y$ дадут $z$. 
Также можно найти одновременно значения нескольких аргументов: $add^o \ ? \ ? \ z$ найдет такие пары чисел, что в сумме они равны $z$, а $add^o \ ? \ ? \ ?$ перечислит все тройки из отношения. 

Таким образом, мы можем говорить о выборе \textit{направления} вычисления. 
Часто при написании программы подразумевается некоторое конкретное направление, называемое \textit{прямым} (например, $add^o  \ x \ y \ ?$), все остальные направления обычно называются \textit{обратными}. 
Возможность выполнения в различных направлениях --- основное преимущество реляционного программирования. 
Это своеобразный шаг к декларативности: достаточно написать одну программу для получения множества целевых функций. 

Реляционному программированию родственно логическое, представленное такими языками, как \prolog{} и \mercury{}\footnote{Официальный сайт языка \mercury{}: \url{https://mercurylang.org/}, дата последнего посещения: 15.02.2020}~\cite{SOMOGYI199617}.
Основным представителем парадигмы реляционного программирования является семейство интерпретируемых языков \miniKanren{}\footnote{Официальный сайт языка \miniKanren{}: \url{http://minikanren.org/}, дата последнего посещения: 15.02.2020}.
Языки семейства \miniKanren{} компактны и встраиваются в языки общего назначения, за счет чего их проще использовать в своих проектах. 
Для встраивания достаточно реализовать интерпретатор языка \miniKanren{}: ядро языка на \scheme{} занимает не более, чем 40 строк~\cite{hemann2013ukanren}.
Помимо этого, \miniKanren{} реализует полный поиск со стратегией interleaving, поэтому любая программа, написанная на нем, найдет все существующие ответы, в то время как \prolog{} может никогда не завершить поиск. 
В этой статье мы будем говорить про \miniKanren{}.

Возможность выполнения программ на \miniKanren{} в различных направлениях позволяет решать задачи поиска посредством решения задачи распознавания~\cite{lozov2019relational}.
Так, имея интерпретатор языка, можно решать задачу синтеза программ на этом языке по набору тестов~\cite{byrd2017unified}; имея функцию, проверяющую, что некоторая последовательность вершин в графе формирует путь с желаемыми свойствами, получать генератор таких путей и так далее. 
$N$-местную функцию-распознаватель, реализованную на некотором языке программирования, можно автоматически транслировать на \miniKanren{}, получив $N+1$-местное отношение, связывающее аргументы функции с булевым значением~\cite{lozov2019relational} (истина соответствует успешному распознаванию). 
Зафиксировав значение $N+1$-ого булевого аргумента, можно выполнять поиск. 
Ценность такого подхода в его простоте: решение задачи поиска всегда труднее, чем реализация распознавателя. 

К сожалению, выполнение отношения в обратном направлении обычно крайне не эффективно. 
В~\cite{lozov2019relational} для решения этой проблемы используется специализация. 
В статье показано, что специализация приводит к существенному приросту скорости работы программы.
Однако чтобы избавиться от всех накладных расходов, связанных с интерпретацией программы, необходим Джонс-оптимальный специализатор~\cite{jones1993partial}. 
К сожалению, реализация такого специализатора --- нетривиальная задача.

В данное время авторами ведется работа над альтернативным подходом улучшения производительности программы в заданном направлении. 
Для этого по отношению с заданным направлением генерируется функция на функциональном языке программирования \haskell{}. 
Таким образом можно избежать затрат на интерпретацию. 
Особенностью реляционного программирования является отсутствие строго порядка исполнения программы: особенно сильно он может разниться для разных направлений.
Это затрудняет трансляцию в функциональные языки программирования. 
Для успешной трансляции необходимо определить порядок исполнения программ с учетом направления. 
Для решения такой задачи используется \textit{анализ времени связывания} (binding time analysis). 
Функционально-логический язык программирования \mercury{} использует анализ времени связывания как шаг компиляции~\cite{vanhoof2004binding}, однако для реляционных языков ранее не применялся.
В данной статье мы представляем алгоритм времени связывания для реляционного программирования. 

В разделе~\ref{miniKanren} мы описываем язык \miniKanren{}, используемый в статье.
Раздел~\ref{translator} содержит схему его трансляции в функциональный язык, а также описание возникающих при этом трудностей.
Алгоритм анализа времени связывания для \miniKanren{} приведен в разделе~\ref{bta}. 
В заключении (раздел ~\ref{conclusion}) мы подводим выводы и описываем планы на дальнейшую работу. 

\section{Язык программирования \miniKanren{}}\label{miniKanren}

Семейство языков \miniKanren{} дало рождение парадигме реляционного программирования. 
Это минималистичные языки, встраиваемые в языки программирования общего назначения. 
Помимо простоты использования при разработке конечных приложений, \miniKanren{} реализует полный поиск: все существующие решения будут найдены, пусть и за длительное время.
Классический представитель родственной парадигмы логического программирования \prolog{} этим свойством не обладает: исполнение программы может не завершиться, даже если не все решения были вычислены. 
Незавершаемость программ на \prolog{} --- свойство стратегии поиска решения.
Для устранения потенциальной нетерминируемости используются нереляционные конструкции, такие как cut. 
Эта особенность существенно усложняет и часто делает невозможным исполнение в обратном направлении. 
Язык \miniKanren{} же является чистым: все языковые конструкции обратимы. 

Программа на \miniKanren{} состоит из набора определений отношений. 
Определение имеет имя, список аргументов и тело.
Тело отношения является \textit{целью}, которая может содержать \textit{унификацию термов} и \textit{вызовы отношений}, скомбинированные при помощи \textit{дизъюнкций} и \textit{конъюнкций}. 
\textit{Терм} представляет собой или \textit{переменную}, или \textit{конструктор} с именем и списком подтермов. 
Свободные переменные вводятся в область видимости при помощи конструкции \underline{fresh}. 

\begin{align*}
  Goal &: Goal \vee Goal \\
       &\mid Goal \wedge Goal \\
       &\mid Term \equiv Term \\
       &\mid \underline{invoke} \ Name \ [Term] \\
       &\mid \underline{fresh} \ [Var] \ Goal \\
  Term &: Var \\ 
       &\mid \underline{cons} \ Name \ [Term]
\end{align*}

Пример программы на языке \miniKanren{}, связывающей три списка, где третий является конкатенацией первых двух, приведен ниже. Мы используем $[]$ как сокращение для пустого списка ($\underline{cons} \ Nil \ []$) и $h : t$ для конструктора списка с головой $h$ и хвостом $t$ ($\underline{cons} \ Cons \ [h, t]$), а $[x_0, x_1, \dots, x_n]$ --- для обозначения списка с элементами $x_0, x_1, \dots, x_n$.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.3\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $append^o$ x y z =
    (x $\equiv$ [] $\wedge$ y $\equiv$ z) $\vee$ |\label{line:ma2}|
    (fresh [h, t, r] (
        x $\equiv$ h : t $\wedge$ |\label{line:ma4}|
        z $\equiv$ h : r $\wedge$ |\label{line:ma5}|
        $append^o$ [t, y, r] |\label{line:ma6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример программы на \miniKanren{}}
  \label{lst:appendoDEF}
\end{figure}

Исполнение этого отношения в прямом направлении на двух заданных списках $append^o \ [1,2] \ [3] \ ?$ вернет их конкатенацию $[1,2,3]$.
Если исполнить его в обратном направлении, оставив первые два аргумента неизвестными, мы получим все возможные разбиения данного списка на два: результатом $append^o \ ? \ ? \ [1,2,3]$ является множество пар $\{([],[1,2,3]), ([1], [2,3]), ([1,2], [3]), ([1,2,3], [])\}$.

\section{Трансляция в функциональный язык}\label{translator}

В этом разделе мы кратко опишем разрабатываемую авторами трансляцию \miniKanren{} в функциональный язык программирования, чтобы продемонстрировать, на решение каких проблем нацелен анализ времени связывания.
Мы будем использовать \haskell{} в качестве целевого языка. 

Отношение, выполненное в заданном направлении, можно рассматривать как функцию из известных аргументов в неизвестные. 
Например, отношение $append^o$, выполненное в прямом направлении ($append^o \ x \ y \ ?$) соответствует функции конкатенации списков $x$ и $y$. 

Отношение $append^o$ состоит из двух дизъюнктов. 
Первый дизъюнкт означает, что если $x$ является пустым списком, то $y$ совпадает с $z$. 
Второй дизъюнкт означает, что $x$ и $z$ являются списками, начинающимися с одного и того же элемента, при этом хвостом $z$ является результат конкатенации хвоста списка $x$ со списком $y$. 
Унификация с участием неизвестной переменной $z$ указывает на то, \emph{как} вычислить её значение, в то время как унификация  известной переменной $x$ --- \emph{при каком условии}.

Автоматическая трансляция $append^o$ в прямом направлении создаст функцию, приведенную на листинге~\ref{lst:appendoFWD}. 
В двух уравнениях первая переменная сопоставляется с образцом. 
В первом случае мы сразу возвращаем второй список как результат, в то время как во втором необходимо осуществить рекурсивный вызов построенной функции. 

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.35\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $append^o$ :: [a] $\to$ [a] $\to$ [a]
  $append^o$ [] y = y
  $append^o$ (h : t) y =
    let r  = $append^o$ t y in 
    h : r 
  \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции $append^o \ x \ y \ ?$}
  \label{lst:appendoFWD}
\end{figure}

Не всегда результатом выполнения отношения является единственный ответ.
Например, при выполнении отношения $append^o$ в обратном направлении ($append^o \ ? \ ? \ z$), \miniKanren{} вычислит \emph{все} возможные \emph{пары} списков, дающие при конкатенации~$z$. 
В общем случае, отношению $R \subseteq X_0 \times \dots \times X_n$, в котором известны аргументы $X_{i_0}, \dots X_{i_k}$, а аргументы $X_{j_0}, \dots X_{j_l}$ необходимо вычислить, соответствует функция $F : X_{i_0} \to \dots \to X_{i_k} \to [X_{j_0} \times \dots \times X_{j_l}]$, возвращающая список результатов. 

Любое отношение можно преобразовать в \emph{нормальную форму}. 
Для упрощения повествования мы будем считать, что все цели нормализованы. 
\emph{Нормальной формой} будем называть дизъюнкцию конъюнкций вызовов отношений или унификаций термов, при этом все свободные переменные введены в область видимости в самом начале:

\begin{align*}
  Goal  &: \underline{fresh} \ [Name] \ (\bigvee \bigwedge Goal') \\
  Goal' &: \underline{invoke} \ Name \ [Term] \\
        &\mid Term \equiv Term 
\end{align*}

Транслятор строит одну функцию для каждого дизъюнкта. 
Дизъюнкты в программе на \miniKanren{} независимы, то есть все ответы из каждого дизъюнкта объединяются для получения результата выполнения отношения. 
Для отношения создается функция, конкатенирующая результаты применения функций, построенных для отдельных дизъюнктов. 

Пример трансляции $append^o \ ? \ ? \ z$ приведен в листинге~\ref{lst:appendoBWD}.  
Унификации неизвестных переменных (например $x \equiv []$ и $x \equiv (h : t)$) при трансляции преобразуются в let-связывания (строки~\ref{line:h2a2} и~\ref{line:h2a10}). 
Рекурсивные вызовы отношений транслируются в рекурсивные вызовы функций, построенных в заданном направлении (см. строку~\ref{line:h2a9}).
Стоит обратить внимание на то, что рекурсивно вызывается функция $append^o$, построенная по всему отношению.
Мы используем do-нотацию языка \haskell{}\footnote{Описание do-нотации языка \haskell{}: \url{https://en.wikibooks.org/wiki/Haskell/do\_notation}, дата последнего посещения: 14.02.2020}.
Связывание в строке~\ref{line:h2a9} означает, что результат будет вычислен для каждого элемента списка, полученного из рекурсивного вызова функции.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.4\textwidth}
    \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $append^o$ :: [a] $\to$ [([a], [a])]
  $append^o$ x = $append^o_1$ x ++ $append^o_2$ x
    where
      $append^o_1$ y = do
        let x = []          |\label{line:h2a2}|
        return (x, y)
      $append^o_1$ _ = []
      
      $append^o_2$ (h : r) = do
        (t, y) $\leftarrow$ $append^o$ r |\label{line:h2a9}|
        let x = h : t       |\label{line:h2a10}|
        return (x, y)
      $append^o_2$ _ = []
      \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Результат трансляции $append^o \ ? \ ? \ z$ }
  \label{lst:appendoBWD}
\end{figure}

Нетрудно заметить, что порядок вычислений в функциях нередко не совпадает с порядком конъюнктов в исходном отношении. 
Например, рекурсивный вызов отношения $append^o$ производится в последнем конъюнкте (см. рис.~\ref{lst:appendoDEF}, строка~\ref{line:ma6}), в то время как в функциях выполняется в первую очередь. 
Если отношение вызывает более одного отношения, то необходимо не только определить порядок, в котором необходимо вызывать функции в результате трансляции, но и в каком направлении это делать. 
Примером может служить отношение $revers^o$ (см. листинг~\ref{lst:reversoDEF}), связывающий список со списком его элементов в обратном порядке.
Это отношение имеет рекурсивный вызов, а также вызов отношения $append^o$. 
Порядок вызовов здесь влияет на направления функций, построенных по этим отношениям.
Выбранные направления также могут влиять на то, в каком порядке необходимо вызывать функции. 
Использование монадических вычислений и do-нотации вынуждает нас заранее определять порядок, в котором будут осуществляться вызовы функций. 

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.35\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $revers^o$ xs sx =
    (xs $\equiv$ [] $\wedge$ sx $\equiv$ []) $\vee$
    (fresh [h, ts, st] (
        x $\equiv$ h : ts $\wedge$
        $revers^o$ ts st $\wedge$
        $append^o$ [st, [h], sx]  
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Отношение $revers^o$}
  \label{lst:reversoDEF}
\end{figure}

Эти особенности диктуют необходимость использования некоторого статического анализа, позволяющего упорядочить вычисления в заданном направлении. 
Анализ времени связывания часто используется при построении offline-специализаторов языков программирования. 
Его задачей является определить, являются ли данные, используемые в программах, статическими (известными заранее) или динамическими (известными только во время вычисления).
Использование анализа времени связывания при функциональной трансляции может также определить порядок вычисления, а по нему --- направлениях, в которых необходимо транслировать используемые отношения. 

\section{Анализ времени связывания для \miniKanren{}}\label{bta}

Цель анализа времени связывания --- указать порядок, в котором имена связываются со значениями.
Алгоритм принимает на вход программу на \miniKanren{}, данные о входных переменных и каждой переменной ставит в соответствие число.
Процесс подбора чисел называется \emph{аннотированием}.

Если о переменной ничего неизвестно --- она аннотируется $Undef$, иначе указывается время связывания --- целое положительное число.
В начале работы алгоритма известными являются переменными, указанные как входные --- они аннотируются $0$.
В процессе работы алгоритма переменная считается известной (или константой к текущему моменту), если она зависит только от проаннотированных числами переменных --- в этом случае она аннотируется числом, большим на $1$ максимальной аннотации переменных, от которых она зависит.
Таким образом информация о времени связывания распространяется на другие переменные.

На аннотациях выполняется порядок: естественный на положительных числах, $Undef$ меньше любой числовой аннотации.
Переаннотирование может происходить только в сторону увеличения аннотации: мы можем воспользоваться переменной позже (указав более позднее время свзязывания), но не можем раньше.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    \draw (1,0) node[below] {Undef};
    \draw (0,.75) node[above] {0};
    \draw (.75,1.25) node[above] {1};
    \draw (1.5,1.75) node[above] {2};
    \draw (2.25,2.25) node[above] {3};
    \draw (1,0) -- (0,.75);
    \draw (1,0) -- (.75,1.25);
    \draw (1,0) -- (1.5,1.75);
    \draw (1,0) -- (2.25,2.25);
    \draw (0,.75) -- (2.25,2.25);
    \draw[dotted] (2.25,2.25) -- (3,2.75);
  \end{tikzpicture}
  \caption{Полурешётка}
  \label{fig:image}
\end{figure}

\subsection{Алгоритм анализ времени связывания}

Реализация разработанного алгоритма доступна на сайте \github{}\footnote{Исходный код алгоритма аннотирования: github.com/Pluralia/uKanren\_translator, дата последнего посещения: 15.02.2020}. Ниже приведено описание алгоритма.

Входные данные алгоритма описаны выше.
Выходные --- пара из проаннотированной нормализованной (приведённой к дизъюнктивной нормальной форме) цели и стека вызовов --- списка аннотированных орпеделений отношений, использованных в цели.

Инициализация алгоритма:
\begin{itemize}
    \item уникально переименовать все $fresh$-переменные, чтобы избежать перекрытия имён;
    \item нормализовать для упрощения алгоритма;
    \item проаннотировать $0$ входные переменные
\end{itemize}

Инициализация цели перед аннотированием:
\begin{itemize}
    \item снять все fresh, дав переменным уникальные имена 
    \item нормализовать
    \item произвести первичное аннотирование цели данными о входных переменных
\end{itemize}

Аннотирование - общий алгоритм:
\begin{itemize}
    \item создать пустой стек вызовов
    \item вычисляем аннотации нормализованной цели, пока не достигнем неподвижной точки
    \item аннотировать нормализованную цель --- аннотировать все её дизъюнкты
\end{itemize}

Аннотировать дизъюнкт --- аннотировать все его конъюнкты, при этом аннотации переменных в дизъюнкте должны согласовываться: переменная в конъюнктах одного и того же дизъюнкта должна иметь одну и ту же аннотацию.
"Отсортируем" конъюнкты: в начале унификации, а затем вызовы других отношений.
Для каждого конъюкнта: согласуем аннотации его переменных с аннотациями всех конъюктов списка до него, а затем вызовем аннотирование конъюнкта.

Аннотировать конъюнкт --- аннотировать либо унификацию, либо вызов отношений.

Аннотирование унификации:
\begin{itemize}
    \item слева переменная с $Undef$-аннотацией --- проаннотировать максимальной аннотацией правого терма, увеличенной на $1$
    \item слева переменная, аннотированная числом --- её значение, увеличенное на 1, установить в качестве значений всех $Undef$-аннотаций правого терма
    \item слева и справа конструкторы --- произвести унификацию их аргументов и запустить рекурсивно аннотирование унификаций
    \item оставшиеся случаи симметричны
\end{itemize}

Аннотирование вызова отношения.
Для избежания повторного аннотированиях информации о проаннотированных в конкретных направлениях отношениях сохраняется в стеке вызовов.
Для поиска пары отношение-направление в стеке по имени отношения получим все его направления --- среди них попытаемся найти направление, согласованное с нашим.
Два направления назовём согласованными, если при сравнении аннотаций их аргументов попарно аннотации одного из направлений будут всегда больше или равны аннотациям другого направления.

Рассмотрим примеры.
Пусть есть направления $[x: 0, y: 0, z: Undef]$ и $[x: 1, y: 0, z: Undef]$.
Они являются согласованными, так как для $x$ $0 < 1$, для $y$ и $z$ аннотации совпадают.
Следующие направления несогласованны, так как аннотации $x$ и $y$ больше у первого направления, а аннотация $z$ больше у второго: $[x: 3, y: 2, z: 0]$ и $[x: 0, y: 0, z: 2]$.

Алгоритм аннотирования вызова отношения:
\begin{itemize}
    \item все термы вызова проаннотированы $Undef$ или все проаннотированы числами --- вернуть исходную цель
    \item вызов с таким именем и направлением есть в стеке вызовов --- заменить $Undef$-аннотации аргументов вызова на максимальную аннотацию аргументов, увеличенную на $1$
    \item вызова с таким именем и направлением нет в стеке вызовов --- добавить его и направление в стек вызовов; проаннотировать цель, вызываемого отношения с учётом обновлённого стека; добавить в стек проаннотированную цель под соответствующим именем и направлением
\end{itemize}

Существуют отношения, в которых некоторые переменные используются только в отношениях.
Пример такого отношения приведён в листинге~\ref{lst:reloBWD}.
Укажем $y$ как входную переменную.
В этом случае отношения $f^o$ и $h^o$ могут вычисляться в любом порядке независимо друг от друга, однако важно время вычислении $g^o$.
Оно не может вычисляться до вычисления $f^o$ и $h^o$ (неизвестны входные переменные), но может вычисляться между ними или после.
При вычислении между ними получим вычисление $g^o$ в прямом или обратном порядке, а после них --- $g^o$ играет роль предиката.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.2\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $rel^o$ x y z =
    f^o x y $\vee$
    h^o z y $\vee$
    g^o x z
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример программы на \miniKanren{}, в которой переменные используются только в отношениях}
  \label{lst:reloDEF}
\end{figure}

При получении такого отношения алгоритм аннотирования может вернуть цель, частично проаннотированную  $Undef$.
В этом случае необходимо запустить алгоритм ещё раз, поменяв порядок вызова отношений при сортировке конъюнктов в соответствующем дизъюнкте.
Если при достижении неподвижной точки в цели останутся $Undef$-переменные, цель считается неаннотируемой.

Предложенный алгоритм терминируем, так как благодаря стеку вызовов не происходит повторного аннотирования отношений, а в каждом отношении используется конечное число переменных, конструкторов и вызовов других отношений.

\subsection{Примеры аннотирования}

Рассмотрим несколько примеров аннотирования.
Числа над переменными обозначают аннотации.

$Пример 1$. Аннотирование цели --- вызов $append^o$ в прямом направлении ($x$ и $y$ --- входные).
Его нет в стеке вызовов, поэтому добавим и запустим рекурсивно аннотирование цели $append^o$. Проаннотированное $append^o$ в листинге~\ref{lst:appendoANN1}.
Так как $x$ и $y$ --- входные, их аннотации нам известны.
Первый дизъюнкт тривиален --- рассмотрим второй.
На следующем шаге становятся известны аннотации $h$ и $t$ --- строка~\ref{line:a1ma4}.
Аннотация $h$ распространяется на~\ref{line:a1mf5} строку, а аннотация $t$ --- на~\ref{line:a1ma6} строку.
Здесь же аннотируем $r$ в вызове отношения~\ref{line:a1ma6} строки: его направление согласованно с тем, что есть в стеке (см. пример согласованности направлений выше).
Распространяем аннотацию $r$ на~\ref{line:a1ma5}.
На последнем шаге аннотируем $z$ из~~\ref{line:a1ma4}.
Теперь необходимо вернуть результат аннотирования $append^o$, основываясь на его дизъюнктах --- аннотация каждого аргумента равна максимальной его аннотации среди всех дизъюнктов.
В первом дизъюнкте $z$ имеет аннотацию $1$, а во втором --- $3$, поэтому результирующая аннотация равна $3$.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.3\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $append^o$ $x^0$ $y^0$ $z^3$ =
    ($x^0$ $\equiv$ [] $\wedge$ $y^0$ $\equiv$ $z^1$) $\vee$ |\label{line:a1ma2}|
    (fresh [h, t, r] (
        $x^0$ $\equiv$ $h^1$ : $t^1$ $\wedge$ |\label{line:a1ma4}|
        $z^3$ $\equiv$ $h^1$ : $r^2$ $\wedge$ |\label{line:a1ma5}|
        $append^o$ [$t^1$, $y^0$, $r^2$] |\label{line:a1ma6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Аннотирование $append^o$ в прямом направлении}
  \label{lst:appendoANN1}
\end{figure}

$Пример 2$. Проаннотируем ту же цель в обратном направлении ($z$ является входной) в листинге~\ref{lst:appendoANN2}.
Пусть $append^o$ уже в стеке и $z$ проаннотирована.
В первом дизъюнкте $x$ и $y$ имеют аннотацию $1$: $y$ определяется входной переменной $z$, а $x$ зависит от константы.
Во втором дизъюнкте при первом шаге становятся известны аннотации $h$ и $r$ --- строка~\ref{line:a2ma5}.
Аннотация $r$ доходит до~\ref{line:a2ma6} строки --- соответствующая пара отношение-направление есть в стеке --- аннотируем $t$ и $y$.
Аннотация $t$ распространяется на~\ref{line:a2ma4} строку, а на последнем шаге аннотируем $x$ в той же строке.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.3\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $append^o$ $x^3$ $y^2$ $z^0$ =
    ($x^1$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ $z^0$) $\vee$ |\label{line:a2ma2}|
    (fresh [h, t, r] (
        $x^3$ $\equiv$ $h^1$ : $t^2$ $\wedge$ |\label{line:a2ma4}|
        $z^0$ $\equiv$ $h^1$ : $r^1$ $\wedge$ |\label{line:a2ma5}|
        $append^o$ [$t^2$, $y^2$, $r^1$] |\label{line:a2ma6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Аннотирование $append^o$ в обратном направлении}
  \label{lst:appendoANN2}
\end{figure}

$Пример 3$. Рассмотрим аннотирование цели --- вызов $revers^o$ в обратном направлении.
$revers^o$ принимает на вход список и возвращает перевёрнутый список.
Его определение приведено в листинге~\ref{lst:reversoAnn2}.
Добавим $revers^o$ по текущему направлению в стек вызовов, вызовем аннотирование и проинициализируем $y$ --- как входную переменную.
Рассмотрим только второй дизъюнкт.
На первом шаге можно попытаться проаннотировать только вызов $append^o$ в строке~\ref{line:r2ma6} --- известна $y$.
Такого отношения в стеке вызовов нет --- добавляем и вызываем аннотирование.
Это и есть вызов $append^o$ в обратном направлении, рассмотренный выше.
Нам вернутся аннотации $r$ и $h$ --- распространяем их по другим конъюнктам.
На следующем шаге можем получить аннотацию $t$ из рекурсивного вызова $revers^o$, так как он уже есть в стеке --- строка~\ref{line:r2ma5}.
Распространяем аннотацию $t$ и аннотируем $x$ на следующем шаге в строке~\ref{line:r2ma4}.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.3\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, escapechar=|]
  $revers^o$ $x^5$ $y^0$ =
    ($x^1$ $\equiv$ [] $\wedge$ $y^1$ $\equiv$ []) $\vee$ |\label{line:r2ma2}|
    (fresh [h, t, r] (
        $x^5$ $\equiv$ $h^2$ : $t^4$ $\wedge$ |\label{line:r2ma4}|
        $revers^o$ [$t^4$, $r^3$] $\wedge$ |\label{line:r2ma5}|
        $append^o$ [$r^3$, $[h^2]$, $y^0$] |\label{line:r2ma6}|
    ))
    \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Аннотирование $revers^o$ в обратном направлении}
  \label{lst:reversoANN2}
\end{figure}

\subsection{Обзор существующих решений}

Анализ времени связывания --- часто применяемая идея анализа программ.
Реализация этой идеи зависит от цели применения, а также особенностей анализируемого, что не позволяет использовать существующие решения в нашем случае.

Так, в \mercury{}~\cite{vanhoof2004binding} анализ времени связывания применяется для специализации программ. Как следствие, этой реализации не требуется размечать порядок связывания переменных --- достаточно разбить их на статические и динамические. Особенностью \mercury{} являются типы, что так же отразилось на итоговом алгоритме (аннотирование происходит с учётом графа типов, построенного по термам).

Существует анализ времени связывания для лямбда-исчисления~\cite{Thiemann1997AUF}. Его цель совпадает с нашей --- получить порядок связывания переменных. В алгоритме, предложенном в статье, для этого используются числа от $0$ до $D$ --- эту идею получилось перенести в анализ времени связывания для \miniKanren{}. Однако, лямбда-исчисление --- функциональное программирование --- использует совершенно другие конструкции.

\section{Заключение}\label{conclusion}

В статье мы представили алгоритм анализа времени связывания для \miniKanren{}. Основной его недостаток --- полный перебор при аннотации переменных, если они используются только в вызовах отношений, и не были проаннотированы ранее. В этом случае необходимо перебрать все возможные направления вычисления отношений, что влияет на эффективность алгоритма.

Также в дальнейшем мы планируем интегрировать анализ времени связывания в транслятор в функциональный язык. По проаннотированной программе можно получить порядок, в котором необходимо привести определения переменных и вызовы функций.

\section*{Благодарность}

Выражаем благодарность Дмитрию Юрьевичу Булычеву и Даниилу Андреевичу Березуну за плодотворные дискуссии и конструктивную критику.

\bibliographystyle{IEEEtran.bst}
\bibliography{IEEEbib.bib}
\end{document}

