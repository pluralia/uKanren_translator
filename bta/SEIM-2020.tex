\documentclass[conference,american,russian]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{listings}
\usepackage{tikz}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\renewcommand{\sfdefault}{cmss}
\renewcommand{\rmdefault}{cmr}
\renewcommand{\ttdefault}{cmt}

\def\IEEEkeywordsname{Ключевые понятия}

\newcommand{\miniKanren}{\textsc{miniKanren}}
\newcommand{\mercury}{\textsc{Mercury}}
\newcommand{\haskell}{\textsc{Haskell}}
\newcommand{\prolog}{\textsc{Prolog}}
\newcommand{\scheme}{\textsc{Scheme}}

\newcommand{\github}{\textsc{GitHub}}

\title{Анализ времени связывания для реляционных программ}

\author{\IEEEauthorblockN{Ирина Артемьева}
\IEEEauthorblockA{\textit{Университет ИТМО} \\
Санкт-Перебург, Россия \\
irinapluralia@gmail.com}
\and
\IEEEauthorblockN{Екатерина Вербицкая}
\textit{JetBrains Research}\\
Санкт-Перебург, Россия \\
kajigor@gmail.com}


\maketitle

\begin{abstract}
Программы в парадигме реляционного программирования представляют собой математические отношения.
Программы-отношения можно исполнять в различных направлениях: зафиксировав часть аргументов программы, находить значение остальных.
Не всегда исполнение программы в заданном направлении эффективно. 
Одним из способов улучшения производительности является трансляция реляционных программ в функциональные. 
Для генерации функции по отношению необходимо определить порядок связывания имен в программе с учетом заданного направления.
Для этого традиционно применяется анализ времени связывания, однако для реляционных языков ранее его разработано не было.
В статье мы предлагаем алгоритм анализа времени связывания для языка реляционного программирования \miniKanren{}. 
\end{abstract}

\begin{IEEEkeywords}
Реляционное программирование, анализ времени связывания, статический анализ
\end{IEEEkeywords}

\section{Введение}

Реляционное программирование --- парадигма, в которой любая программа описывает математическое отношение на ее аргументах. 
Имея программу-отношение, можно выполнять запросы: указывая некоторые известные аргументы, получать значения остальных.
Например, $add^o \subseteq Int \times Int \times Int$ описывает отношение, третий аргумент которого является суммой первых двух. 
Рассмотрим возможные направления вычисления этого отношения (здесь и далее входной аргумент будем обозначать $?$).
Выполнение отношения $add^o  \ x \ y \ ?$ с зафиксированными (выходными) первым и вторым аргументом найдет их сумму, а $add^o \ ? \ y \ z$ найдет такие числа, которые в сумме с $y$ дадут $z$. 
Также можно найти одновременно значения нескольких аргументов: $add^o \ ? \ ? \ z$ найдет такие пары чисел, что в сумме они равны $z$, а $add^o \ ? \ ? \ ?$ перечислит все тройки из отношения. 

Таким образом, мы можем говорить о выборе \textit{направления} вычисления. 
Часто при написании программы подразумевается некоторое конкретное направление, называемое \textit{прямым} (например, $add^o  \ x \ y \ ?$), все остальные направления обычно называются \textit{обратными}. 
Возможность выполнения в различных направлениях --- основное преимущество реляционного программирования. 
Это своеобразный шаг к декларативности: достаточно написать одну программу для получения множества целевых функций. 

Реляционному программированию родственно логическое, представленное такими языками, как \prolog{} и \mercury{}\footnote{Официальный сайт языка \mercury{}: http://mercurylang.org/, дата последнего посещения: 11.02.2020}~\cite{SOMOGYI199617}.
Основным представителем парадигмы реляционного программирования является семейство интерпретируемых языков \miniKanren{}\footnote{Официальный сайт языка \miniKanren{}: http://minikanren.org/, дата последнего посещения: 11.02.2020}.
Языки семейства \miniKanren{} компактны и встраиваются в языки общего назначения, за счет чего их проще использовать в своих проектах. 
Для встраивания достаточно реализовать интерпретатор языка \miniKanren{}: ядро языка на \scheme{} занимает не более, чем 40 строк~\cite{hemann2013ukanren}.
Помимо этого, \miniKanren{} реализует полный поиск со стратегией interleaving, поэтому любая программа, написанная на нем, найдет все существующие ответы, в то время как \prolog{} может никогда не завершить поиск. 
В этой статье мы будем говорить про \miniKanren{}.

Возможность выполнения программ на \miniKanren{} в различных направлениях позволяет решать задачи поиска посредством решения задачи распознавания~\cite{lozov2019relational}.
Так, имея интерпретатор языка, можно решать задачу синтеза программ на этом языке по набору тестов~\cite{byrd2017unified}; имея функцию, проверяющую, что некоторая последовательность вершин в графе формирует путь с желаемыми свойствами, получать генератор таких путей и так далее. 
$N$-местную функцию-распознаватель, реализованную на некотором языке программирования, можно автоматически транслировать на \miniKanren{}, получив $N+1$-местное отношение, связывающее аргументы функции с булевым значением~\cite{lozov2019relational} (истина соответствует успешному распознаванию). 
Зафиксировав значение $N+1$-ого булевого аргумента, можно выполнять поиск. 
Ценность такого подхода в его простоте: решение задачи поиска всегда труднее, чем реализация распознавателя. 

К сожалению, выполнение отношения в обратном направлении обычно крайне не эффективно. 
В~\cite{lozov2019relational} для решения этой проблемы используется специализация. 
В статье показано, что специализация приводит к существенному приросту скорости работы программы.
Однако чтобы избавиться от всех накладных расходов, связанных с интерпретацией программы, необходим Джонс-оптимальный специализатор~\cite{jones1993partial}. 
К сожалению, реализация такого специализатора --- нетривиальная задача.

В данное время авторами ведется работа над альтернативным подходом улучшения производительности программы в заданном направлении. 
Для этого по отношению с заданным направлением генерируется функция на функциональном языке программирования \haskell{}. 
Таким образом можно избежать затрат на интерпретацию. 
Особенностью реляционного программирования является отсутствие строго порядка исполнения программы: особенно сильно он может разниться для разных направлений.
Это затрудняет трансляцию в функциональные языки программирования. 
Для успешной трансляции необходимо определить порядок исполнения программ с учетом направления. 
Для решения такой задачи используется \textit{анализ времени связывания} (binding time analysis). 
Функционально-логический язык программирования \mercury{} использует анализ времени связывания как шаг компиляции~\cite{vanhoof2004binding}, однако для реляционных языков ранее не применялся.
В данной статье мы представляем алгоритм времени связывания для реляционного программирования. 

В разделе~\ref{miniKanren} мы описываем язык \miniKanren{}, используемый в статье.
Раздел~\ref{translator} содержит схему его трансляции в функциональный язык, а также описание возникающих при этом трудностей.
Алгоритм анализа времени связывания для \miniKanren{} приведен в разделе~\ref{bta}. 
В заключении (раздел ~\ref{conclusion}) мы подводим выводы и описываем планы на дальнейшую работу. 

\section{Язык программирования \miniKanren{}}\label{miniKanren}

Семейство языков \miniKanren{} дало рождение парадигме реляционного программирования. 
Это минималистичные языки, встраиваемые в языки программирования общего назначения. 
Помимо простоты использования при разработке конечных приложений, \miniKanren{} реализует полный поиск: все существующие решения будут найдены, пусть и за длительное время.
Классический представитель родственной парадигмы логического программирования \prolog{} этим свойством не обладает: исполнение программы может не завершиться, даже если не все решения были вычислены. 
Незавершаемость программ на \prolog{} --- свойство стратегии поиска решения.
Для устранения потенциальной нетерминируемости используются нереляционные конструкции, такие как cut. 
Эта особенность существенно усложняет и часто делает невозможным исполнение в обратном направлении. 
Язык \miniKanren{} же является чистым: все языковые конструкции обратимы. 

Программа на \miniKanren{} состоит из набора определений отношений. 
Определение имеет имя, список аргументов и тело.
Тело отношения является \textit{целью}, которая может содержать \textit{унификацию термов} и \textit{вызовы отношений}, скомбинированные при помощи \textit{дизъюнкций} и \textit{конъюнкций}. 
\textit{Терм} представляет собой или \textit{переменную}, или \textit{конструктор} с именем и списком подтермов. 
Свободные переменные вводятся в область видимости при помощи конструкции \underline{fresh}. 

\begin{align*}
  Goal &: Goal \vee Goal \\
       &\mid Goal \wedge Goal \\
       &\mid Term \equiv Term \\
       &\mid \underline{invoke} \ Name \ [Term] \\
       &\mid \underline{fresh} \ [Var] \ Goal \\
  Term &: Var \\ 
       &\mid \underline{cons} \ Name \ [Term]
\end{align*}

Пример программы на языке \miniKanren{}, связывающей три списка, где третий является конкатенацией первых двух, приведен ниже. Мы используем $[]$ как сокращение для пустого списка ($\underline{cons} \ Nil \ []$) и $h : t$ для конструктора списка с головой $h$ и хвостом $t$ ($\underline{cons} \ Cons \ [h, t]$), а $[x_0, x_1, \dots, x_n]$ --- для обозначения списка с элементами $x_0, x_1, \dots, x_n$.

\begin{lstlisting}[frame=single, escapechar=|]
appendo x y xy =
    (x == [] /\ y == xy) \/         |\label{line:ma2}|
    (fresh [h, t, r] (         
        x == h : t  /\              |\label{line:ma4}|
        xy == h : r /\              |\label{line:ma5}|
        invoke "appendo" [t, y, r]  |\label{line:ma6}|
    ))
\end{lstlisting}

Исполнение этого отношения в прямом направлении на двух заданных списках $append^o \ [1,2] \ [3] \ ?$ вернет их конкатенацию $[1,2,3]$.
Если исполнить его в обратном направлении, оставив первые два аргумента неизвестными, мы получим все возможные разбиения данного списка на два: результатом $append^o \ ? \ ? \ [1,2,3]$ является множество пар $\{([],[1,2,3]), ([1], [2,3]), ([1,2], [3]), ([1,2,3], [])\}$.

\section{Трансляция в функциональный язык}\label{translator}

В этом разделе мы кратко опишем разрабатываемую авторами трансляцию \miniKanren{} в функциональный язык программирования, чтобы продемонстрировать, на решение каких проблем нацелен анализ времени связывания.
Мы будем использовать \haskell{} в качестве целевого языка. 

Отношение, выполненное в заданном направлении, можно рассматривать как функцию из известных аргументов в неизвестные. 
Например, отношение $append^o$, выполненное в прямом направлении ($append^o \ x \ y \ ?$) соответствует функции конкатенации списков $x$ и $y$. 

Отношение $append^o$ состоит из двух дизъюнктов. 
Первый дизъюнкт означает, что если $x$ является пустым списком, то $y$ совпадает с $z$. 
Второй дизъюнкт означает, что $x$ и $z$ являются списками, начинающимися с одного и того же элемента, при этом хвостом $z$ является результат конкатенации хвоста списка $x$ со списком $y$. 
Унификация с участием неизвестной переменной $z$ указывает на то, \emph{как} вычислить её значение, в то время как унификация  известной переменной $x$ --- \emph{при каком условии}.

Автоматическая трансляция $append^o$ в прямом направлении создаст функцию, приведенную на листинге~\ref{lst:appendoFWD}. 
В двух уравнениях первая переменная сопоставляется с образцом. 
В первом случае мы сразу возвращаем второй список как результат, в то время как во втором необходимо осуществить рекурсивный вызов построенной функции. 

\begin{figure}[ht!]
  \centering
  \begin{lstlisting}[language=Haskell, frame=single]
    appendo [] y = y
    appendo (h : t) y =
      let r  = appendo t y in 
      h : r 
  \end{lstlisting}
  \caption{Результат трансляции $append^o \ x \ y \ ?$}
  \label{lst:appendoFWD}
\end{figure}

Не всегда результатом выполнения отношения является единственный ответ.
Например, при выполнении отношения $append^o$ в обратном направлении ($append^o \ ? \ ? \ z$), \miniKanren{} вычислит \emph{все} возможные \emph{пары} списков, дающие при конкатенации~$z$. 
В общем случае, отношению $R \subseteq X_0 \times \dots \times X_n$, в котором известны аргументы $X_{i_0}, \dots X_{i_k}$, а аргументы $X_{j_0}, \dots X_{j_l}$ необходимо вычислить, соответствует функция $F : X_{i_0} \to \dots \to X_{i_k} \to [X_{j_0} \times \dots \times X_{j_l}]$, возвращающая список результатов. 

Любое отношение можно преобразовать в \emph{нормальную форму}. 
Для упрощения повествования мы будем считать, что все цели нормализованы. 
\emph{Нормальной формой} будем называть дизъюнкцию конъюнкций вызовов отношений или унификаций термов, при этом все свободные переменные введены в область видимости в самом начале:

\begin{align*}
  Goal  &: \underline{fresh} \ [Name] \ (\bigvee \bigwedge Goal') \\
  Goal' &: \underline{invoke} \ Name \ [Term] \\
        &\mid Term \equiv Term 
\end{align*}

Транслятор строит одну функцию для каждого дизъюнкта. 
Дизъюнкты в программе на \miniKanren{} независимы, то есть все ответы из каждого дизъюнкта объединяются для получения результата выполнения отношения. 
Для отношения создается функция, конкатенирующая результаты применения функций, построенных для отдельных дизъюнктов. 





% % Рассмотрим схему трансляции \miniKanren{} в \haskell{} в первом приближении.
% % Отношение с выбранным направлением соответствует одной функции.
% % Каждая дизъюнкция~--- новое уравнение этой функции.
% % Конъюнкция представляет собой или унификацию, или вызов другого отношения.
% % При трансляции все вызовы превращаются в определения переменных, а унификации~--- либо так же в определения переменных, либо становятся переменными сопоставления с образцом для соответствующего уравнения.
% % В результате трансляции ожидается получить функцию на \haskell{}, семантика вычисления которой соответствует семантике вычисления отношения в выбранном направлении на \miniKanren{}.
% % Так же ожидается, что время выполнения вычислений на \haskell{} будет ощутимо меньше времени выполнения на \miniKanren{}.
% % Рассмотрим примеры трансляции $append^o$ в различных направлениях.

% % При прямом направлении первый и второй аргументы --- входные, третий --- выходной.
% % Здесь два дизъюнкта, поэтому функция на \haskell{} состоит из двух уравнений.
% % В первом дизъюнкте~\ref{line:l2} два конъюнкта-унификации.
% % Первый становится сопоставлением с образцом первого аргумента, а второй~--- определением, которое позволяет получить значение третьего аргумента.
% % Во втором дизъюнкте три конъюнкта.
% % Первый~\ref{line:l4} --- унификация, первого аргумента --- становится сопоставлением с образцом.
% % Второй~\ref{line:l5} --- так же унификация --- становится определением третьего аргумента.
% % Третий~\ref{line:l6} --- вызов отношения $appned^o$ --- должен стать определением.
% % На данном этапе необходимо определить подходящее направление вычисления вызываемого отношения.
% % Так как мы знаем, что данный вызов рекурсивный --- будем считать, что направление соответствует направлению при трансляции.
% % Пример соответствующей трансляции в язык \haskell{} приведён ниже.

% \begin{lstlisting}[language=Haskell, frame=single, escapechar=|]
% appendo [] y = xy
%   where
%     xy = y
% appendo (h : t) y = xy
%   where
%     r  = appendo t y |\label{line:h1a6}|
%     xy = h : r
% \end{lstlisting}

Транслируем в обратном направлении: третий аргумент --- входной, первый и второй --- выходные.
Для данного отношения два выходных аргумента гарантируют недетерминированность.
Трансляция первого дизъюнкта тривиальна --- для возвращения нескольких переменных будем использовать кортеж; недетерминированности в этом дизъюнкте нет.
Во втором дизъюнкте есть рекурсивный вызов~--- по нашей эвристике его направление совпадает с направлением при трансляции.
По семантике вызова $append^o$ на таком направлении вернётся список пар списков, конкатенация которых даст исходный список --- недетерминированность.
Для её поддержки сделано следующее:
\begin{itemize}
    \item вычисление результата вызова отношения в монаде списка;
    \item каждое уравнение функции теперь отдельная функция, возвращающая пустой список в случае неудачи;
    \item результаты всех уравнений-функций объедим при помощи конкатенации в функции на верхнем уровне;
    \item рекурсивные вызовы внутри уравнений-функций относятся к функции на верхнем уровне (в примере ниже $append^02$ вызывает $append^o$).
\end{itemize}

\begin{lstlisting}[language=Haskell, frame=single, escapechar=|]
appendo x = appendo1 x ++ appendo2 x
  where
    appendo1 y = do
      let x = []
      return (x, y)
    appendo1 _ = []
    
    appendo2 (h : r) = do
      (t, y) <- appendo r |\label{line:h2a9}|
      let x = h : t       |\label{line:h2a10}|
      return (x, y)
    appendo2 _ = []
\end{lstlisting}

Анализируя примеры трансляции, можно сделать несколько выводов.

Первый. Направление вычисления отношения влияет на порядок вычислений внутри этого отношения.
При вычислении второго дизъюнкта в прямом направлении конъюнкты вычисляются в порядке~\ref{line:ma4}~\ref{line:ma6}~\ref{line:ma5}, а в обратном направлении --- ~\ref{line:ma5}~\ref{line:ma6}~\ref{line:ma4}.

Второй. Направление вычисления отношения влияет на выбор направления вычисления конъюнктов (унификаций и вызов отношения).
При трансляции первого дизъюнкта в прямом направлении унификация $x$ и пустого списка в~\ref{line:ma2} уходит в сопоставление с образцом, где происходит попытка присвоения $x$ пустому списку.
В обратном направлении унификация $x$ присваивается пустой список.
Рекурсивные вызовы в примерах выше также происходят в разных направлениях.
При прямом порядке третий аргумент --- выходной~\ref{line:h1a6}, а при обратном --- входной~\ref{line:h2a9}.
В примерах для определения направления вызываемых отношений достаточно использовать эвристику, так как вызовы рекурсивны.
На практике при трансляции необходимо определять как направление вычисления вызываемых отношений, так и унификаций.

Третий. Использование монад накладывает ограничение на порядок определения переменных.
В последнем примере нельзя поменять местами~\ref{line:h2a9} и~\ref{line:h2a10} в функции $append^02$.

ИСТОРИЧЕСКАЯ СПРАВКА О BTA

Анализ времени связывания решает обе эти проблемы: аннотируя каждую переменную цели временем связывания, можно выбрать направление вычислений внутренних целей, и по аннотациям восстановить верный порядок определений.

\section{Анализ времени связывания для \miniKanren{}}\label{bta}

Алгоритм получает на вход цель, данные о входных переменных и каждой переменной цели ставит в соответствие число.
Процесс подбора чисел называется \textit{аннотированием}.

Инициализация алгоритма состоит из двух частей:
\begin{itemize}
    \item уникально переименовать все $fresh$-переменные, чтобы избежать перекрытия имён;
    \item нормализовать (привести к дизъюнктивной нормальной форме) для упрощения алгоритма;
\end{itemize}

Опишем шаг алгоритма.

---------------------------------------------------------------------------------

Анализ времени связывания~--- это статический анализ, использующий монотонный фреймворк~\cite{kam1977monotone} --- тройку из полурешётки $L$, $meet$-операции и множества монотонных функций $F$, ассоциированных с конкретными экземплярами полурешётки $L$, и удовлетворяющих свойству монотонности.

В нашем случае элементы полурешётки $L$ --- аннотации. Аннотация может быть или $Undef$ (наименьший элемент) для случая, когда о переменной ничего не известно, или целое число --- время связывания переменной. На целых числах соблюдается естественный порядок, а $Undef$ считается меньше численной аннотации. 

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    \draw (1,0) node[below] {Undef};
    \draw (0,.75) node[above] {0};
    \draw (.75,1.25) node[above] {1};
    \draw (1.5,1.75) node[above] {2};
    \draw (2.25,2.25) node[above] {3};
    \draw (1,0) -- (0,.75);
    \draw (1,0) -- (.75,1.25);
    \draw (1,0) -- (1.5,1.75);
    \draw (1,0) -- (2.25,2.25);
    \draw (0,.75) -- (2.25,2.25);
    \draw[dotted] (2.25,2.25) -- (3,2.75);
  \end{tikzpicture}
  \caption{Полурешётка}
  \label{fig:image}
\end{figure}

Операция $meet$ устроена так, чтобы обеспечивать монотонность: переменная, проаннотированная значением $n$, никогда не будет проаннотирована значением, меньшим $n$. Таким образом, из $Undef$ аннотации можно перейти в любую численную аннотацию, а из численной аннотации можно перейти в численную аннотацию не меньшую текущей.

Цель анализа времени связывания — указать порядок, в котором имена связываются со значениями. Когда алгоритм принимает цель с указанием направления, он выполняет первичное аннотирование --- входные аргументы считаются известными в момент времени 0, поэтому получают аннотацию 0, остальные аргументы получают аннотацию $Undef$. Переменные, проаннотированные числами, считаются известными или константами к текущему моменту времени, поэтому $Undef$-переменные, зависящие только от проаннотированных переменных, могут получить свою аннотацию, значение которой будет больше на 1 самого большого значения аннотации переменных, от которых она зависит. Таким образом информация о времени связывания может распространяться на другие переменные.

Реализация разработанного алгоритма доступна на \github{}\footnote{github.com/Pluralia/uKanren\_translator}. Опишем работу алгоритма.

Входные и выходные данные
\begin{itemize}
    \item принимает программу на \miniKanren{} и список входных переменных
    \item возвращает пару из проаннотированной нормализованной цели (приведённой к дизъюнктивной нормальной форме) и стека вызовов (отображения из названия отношения во множество информации о будущей функции: направление вычисления отношения и цель, размеченная по этому направлению)
\end{itemize}

Инициализация цели перед аннотированием
\begin{itemize}
    \item снять все fresh, дав переменным уникальные имена 
    \item нормализовать
    \item произвести первичное аннотирование цели данными о входных переменных
\end{itemize}

Аннотирование
\begin{itemize}
    \item создать пустой стек вызовов
    \item до fix point --- вычисляем аннотации нормализованной цели, пока не достигнем неподвижной точки
    \item аннотировать нормализованную цель --- аннотировать все её дизъюнкты
    \item аннотировать дизъюнкт --- аннотировать все его конъюнкты (последовательно передавая стек вызовов), а затем распространить информацию об аннотировании между конъюнктами: для каждой переменной дизъюнкта получить её аннотации из всех конъюнктов, найти максимальную и установить её значение в качестве аннотации этой переменной во всём дизъюнкте
    \item аннотировать конъюнкт --- аннотировать либо унификацию, либо вызов отношения
    \item аннотировать унификацию
    \begin{itemize}
        \item слева переменная с $Undef$-аннотацией --- получить максимальную аннотацию правого терма, увеличить её на 1 и присвоить аннотации левого терма
        \item слева переменная, аннотированная числом --- увеличить её значение на 1 и установить в качестве значения всех $Undef$-аннотаций правого терма
        \item слева и справа конструкторы --- произвести $zip$ аргументов и вызвать аннотацию аргументов для каждой пары; полученные унификации разбить на два списка аргументов конструкторов
        \item оставшиеся случаи зеркальны и обрабатываются аналогично
    \end{itemize}
    \item аннотировать вызов отношения:
    \begin{itemize}
        \item если все термы вызова проаннотированы $Undef$ или все проаннотированы числами, вернуть исходную цель
        \item если вызов с таким именем и направлением есть в стеке вызовов, определить максимальную аннотацию аргументов вызова, неравную $Undef$, увеличить её на 1 и проаннотировать её значением переменные с $Undef$-аннотацией
        \item если в стеке нет вызова с таким именем и направлением, добавить его и текущее направление в стек вызовов, проаннотировать цель, полученную по имени, с учётом текущего направления и обновлённого стека вызовов, обновить стек ещё раз: данному вызову и данному направлению доавить проаннотированную цель
    \end{itemize}
\end{itemize}

Пример работы~--- отношение $revers^o$
\begin{align*}
revers^o \ &x \ y = \\
           &(x \equiv [] \wedge y \equiv []) \ \vee \\
           &(\underline{fresh} \ [h, t, r] ( \\
           & \ x \equiv h : t \ \wedge \\
           & \ \underline{call} \ revers^o \ t \ r \ \wedge \\ 
           & \ \underline{call} \ append^o \ r \ [h] \ y ))
\end{align*}

Рассмотрим его аннотирование в направлении $y$~--- входная переменная

Пример работы~--- проаннотируем $append^o$

\section{Заключение}\label{conclusion}

В статье мы представили алгоритм анализа времени связывания для \miniKanren{}. Основной его недостаток --- полный перебор при аннотации переменных, если они используются только в вызовах отношений, и не были проаннотированы ранее. В этом случае необходимо перебрать все возможные направления вычисления отношений. Вопрос об эффективном и корректном способе обработки таких ситуаций на данный момент остается открытым.

Также в дальнейшем мы планируем интегрировать анализ времени связывания в транслятор в функциональный язык. По проаннотированной программе можно получить порядок, в котором необходимо привести определения переменных и вызовы функций.

\section*{Благодарность}

Выражаем благодарность Дмитрию Юрьевичу Булычеву и Даниилу Андреевичу Березуну за плодотворные дискуссии и конструктивную критику.

\bibliographystyle{IEEEtran.bst}
\bibliography{IEEEbib.bib}
\end{document}

