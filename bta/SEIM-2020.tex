\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}


\newcommand{\miniKanren}{\textsc{miniKanren}}
\newcommand{\mercury}{\textsc{Mercury}}
\newcommand{\haskell}{\textsc{Haskell}}
\newcommand{\prolog}{\textsc{Prolog}}
\newcommand{\scheme}{\textsc{Scheme}}


\title{Анализ времени связывания для реляционных программ}

\author{\IEEEauthorblockN{1\textsuperscript{st} Ирина Артемьева}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
Saint-Petersburg, Russia \\
email address or ORCID}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Екатерина Вербицкая}
\textit{JetBrains Research}\\
Санкт-Перебург \\
kajigor@gmail.com}


\maketitle

\begin{abstract}
Программы в парадигме реляционного программирования представляют собой математические отношения.
Программы-отношения можно исполнять в различных направлениях: зафиксировав часть аргументов программы, находить значение остальных.
Не всегда исполнение программы в заданном направлении эффективно. 
Одним из способов улучшения производительности является трансляция реляционных программ в функциональные. 
Для генерации функции по отношению необходимо определить порядок связывания имен в программе с учетом заданного направления.
Для этого традиционно применяется анализ времени связывания, однако для реляционных языков ранее его разработано не было.
В статье мы предлагаем алгоритм анализа времени связывания для языка реляционного программирования \miniKanren{}. 
\end{abstract}

\begin{IEEEkeywords}
Реляционное программирование, анализ времени связывания
\end{IEEEkeywords}

\section{Введение}

Реляционное программирование~--- парадигма, в которой любая программа описывает математическое отношение на ее аргументах. 
Имея программу-отношение, можно выполнять запросы: указывая некоторые известные аргументы, получать значения остальных.
Например, $add^o \subseteq Int \times Int \times Int$ описывает отношение, третий аргумент которого является суммой первых двух. 
Выполнение отношения $add^o  \ x \ y \ ?$ с зафиксированными первым и вторым аргументом найдет их сумму, а $add^o \ ? \ y \ z$ найдет такие числа, которые в сумме с $y$ дадут $z$. 
Также можно найти одновременно значения нескольких аргументов: $add^o \ ? \ ? \ z$ найдет такие пары чисел, что в сумме они равны $z$, а $add^o \ ? \ ? \ ?$ перечислит все тройки из отношения. 

Таким образом, мы можем говорить о выборе \emph{направления} вычисления. 
Часто при написании программы подразумевается некоторое конкретное направление, называемое \emph{прямым} (например, $add^o  \ x \ y \ ?$), все остальные направления обычно называются \emph{обратными}. 
Возможность выполнения в различных направлениях --- основное преимущество реляционного программирования. 
Это своеобразный шаг к декларативности: достаточно написать одну программу для получения множества целевых функций. 

Реляционному программированию родственно логическое, представленное такими языками, как \prolog{} и \mercury{}.
Основным представителем парадигмы реляционного программирования является семейство интерпретируемых языков \miniKanren{}. 
Языки семейства \miniKanren{} компактны и встраиваются в языки общего назначения, за счет чего их проще использовать в своих проектах. 
Для встраивания достаточно реализовать интерпретатор языка \miniKanren{}: ядро языка на \scheme{} занимает не более, чем 40 строк. 
Помимо этого, \miniKanren{} реализует полный поиск со стратегией interleaving, поэтому любая программа, написанная на нем, найдет все существующие ответы, в то время как \prolog{} может никогда не завершить поиск. 
В этой статье мы будем говорить про \miniKanren{}.

Возможность выполнения программ на \miniKanren{} в различных направлениях позволяет решать задачи поиска посредством решения задачи распознавания~\cite{lozov2019relational}.
Так, имея интерпретатор языка, можно решать задачу синтеза программ на этом языке по набору тестов~\cite{byrd2017unified}; имея функцию, проверяющую, что некоторая последовательность вершин в графе формирует путь с желаемыми свойствами, получать генератор таких путей и так далее. 
$N$-местную функцию-распознаватель, реализованную на некотором языке программирования, можно автоматически транслировать на \miniKanren{}, получив $N+1$-местное отношение, связывающее аргументы функции с булевым значением~\cite{lozov2019relational} (истина соответствует успешному распознаванию). 
Зафиксировав значение $N+1$-ого булевого аргумента, можно выполнять поиск. 
Ценность такого подхода в его простоте: решение задачи поиска всегда труднее, чем реализация распознавателя. 

К сожалению, выполнение отношения в обратном направлении обычно крайне не эффективно. 
В~\cite{lozov2019relational} для решения этой проблемы используется специализация. 
В статье показано, что специализация приводит к существенному приросту скорости работы программы.
Однако чтобы избавиться от всех накладных расходов, связанных с интерпретацией программы, необходим Джонс-оптимальный специализатор~\cite{jones1993partial}. 
К сожалению, реализация такого специализатора --- нетривильная задача.

В данное время авторами ведется работа над альтернативным подходом улучшения производительности программы в заданном направлении. 
Для этого по отношению с заданным направлением генерируется функция на функциональном языке программирования \haskell{}. 
Таким образом можно избежать затрат на интерпретацию. 
Особенностью реляционного программирования является отсутствие строго порядка исполнения программы: особенно сильно он может разниться для разных направлений.
Это затрудняет трансляцию в функциональные языки программирования. 
Для успешной трансляции необходимо определить порядок исполнения программ с учетом направления. 
Для решения такой задачи используется \emph{анализ времени связывания} (binding time analysis). 
Функционально-логический язык программирования \mercury использует анализ времени связывания как шаг компиляции~\cite{vanhoof2004binding}, однако для реляционных языков ранее не применялся.
В данной статье мы представляем алгоритм времени связывания для реляционного программирования. 

В разделе~\ref{miniKanren} мы описываем язык \miniKanren{}, используемый в статье, схему его трансляции в функциональный язык и возникающие при этом трудности. 
Алгоритм анализа времени связывания для \miniKanren{} приведен в разделе~\ref{bta}. 
В заключении (раздел ~\ref{conclusion}) мы подводим выводы и описываем планы на дальнейшую работу. 

\section{Язык программирования \miniKanren{}}\label{miniKanren}

\miniKanren - особенный язык в мире реляционного программирования: его минималистичность и чистота породили интерес ко всей парадигме. Рассмотрим его подробнее: конструкции и примеры исполнения при выборе различных направлений.

Первая конструкция называется \emph{термом} - это либо переменная, либо конструктор, содержащий кортеж термов.

Любое отношение состоит из трёх частей: имя, имена аргументов (аналогично объявлению свежих переменных) и цель.

Следующая конструкция - \emph{цель}. Целью может быть унификация двух термов, дизъюнкция и конъюнкция двух целей, вызов какого-то другого отношения по имени с передачей аргументов (в качестве которых выступают термы); перед использованием ранее неизвестных переменных внутри цели их нужно "объявить" аналогично свежим переменным в лямбда-исчислении - такая конструкция так же является целью.

Программа на \miniKanren - список отношений (может быть пустым) и цель, которая может вызывать эти отношения.

Рассмотрим простой пример. Пусть у нас есть отношение (указано без цели; его семантика указана в фигурных скобках):
$$\begin{aligned}sum~x~y~z~=~\{~z~|~x~+~y~==~z~\}\end{aligned}$$

В зависимости от выбора направления вычислений мы можем получить из этого отношения следующие функции (выходные аргументы обозначены $?$):
\begin{itemize}
    \item $add~a~b~=~sum~a~b~?$
    \item $double~a~=~sum~a~a~?$
    \item $substract~a~b~=~sum~?~b~a$
    \item $addends~a~=~sum~?~?~a$
\end{itemize}

$addends$ здесь выступает примером обратного вычисления функции: она возвращает все возможные пары чисел, сумма которых может дать $a$. Отдельно стоит отметить, что в данном случае мы получили недетерменированный ответ: могут существовать несколько пар чисел, сумма которых будет давать исходное число.

Перейдём к особенностям трансляции в функциональный язык. Как уже было сказано, выбор направления вычисления отношения влияет на порядок вычислений внутри этого отношения. Это означает, что при трансляции одного и того же отношения в разных направлениях цели внутри этих отношений будут вычисляться в разном порядке. Тем не менее, мы знаем, что в \haskell есть \emph{let} и \emph{where}, внутри которых порядок объявлений не важен. Почему мы не можем их использовать и забыть об анализе времени связывания?

Проблема возникает по двум причинам. Первая проблема - необходимо поддерживать недетерменированность (пример с \emph{addends}), что накладывает ограничения на использование \emph{let} и \emph{where}. Вторая проблема - для задания объявления по отношениям необходимо определять их направления. Рассмотрим подробнее каждую из проблем.

Недетерменированность - одна из вещей, которую необходимо сохранить при трансляции в функциональный язык. В \haskell есть монада списка, которая идеально позволяет справиться с возникшей проблемой: будем использовать do-нотацию и, если необходимо обработать унификацию - пишем let, а, если вызов отношения (вернёт список), то развернём как монаду. В конце все ответы соберём в кортеж и сделаем return, запаковав всё обратно в списковую монаду. Это способ решения проблемы поддержания недетерменированности, но проблема в том, что в do-нотации порядок объявлений важен - их нужно упорядочивать.

Касательно выбора направления объявлений - поймём, из чего происходят объявления: существует два типа целей, которые связывают переменные: унификация и вызов другого отношения. Ни тот, ни другой тип цели, очевидно, не имеют направления вычисления в \miniKanren. Это значит, что его нужно определять в процессе, "на лету", по данным о направлении вычисления исходного отношения. Для унификации необходимо понять, левая часть присваивается правой или наоборот, а для вызовов функций нужно научиться определять направление.

Анализ времени связывания решает обе эти проблемы: аннотируя каждую переменную цели временем связывания, можно выбрать направление вычисления внутренних целей, и по аннотациям восстановить верный порядок объявлений.

\section{Анализ времени связывания для \miniKanren}\label{bta}

При реализации алгоритма анализа времени связывания были использованы идеи монотонного фреймворка~\cite{kam1977monotone}. Другими словами, то, что необходимо сделать для 

\# Алгоритм

\#\# Общее описание
- принимает программу и список input-переменных
- возвращает пару из проаннаториванной нормализованной цели и стека (мапа из названия отношения во множество информации о будущей функции; эта информация включает направление вычисления отношения и цель, размеченную по этому направлению)


\#\# translate
1. Получаем gamma
2. Инициализируем goal
  - снимаем все fresh и переименовываем переменные
  - нормализуем
  - аннотируем инфой об аргументах, а также инфой о константах
3. Запускаем аннотирование (`annotate`)

\#\# annotate / annotateInternal
4. Добавляем к цели пустой стек 
5. До fix point (пара из цели и стека не изменилась с предыдущего вызова) будем вызывать `annotateGoal`

\#\# annotateGoal
6. Последовательно пройдёмся по всем дизъюнктам: `annotateDisj` передаём текущий disj и стек после вычислений всех предыдущих disjs

\#\# annotateDisj
7. То же, что и в `annotateGoal`, но обходим конъюнкты (функция `annotateConj`) - в конце делаем `meetGoal` между всеми конъюнктами

\#\# meetGoal
- принимает список конъюнктов, получаем все-все переменные из них, сортирует, группирует - получаем переменную и её аннотации со всех конъюнктов; для каждой переменной на всех её аннотациях вызываем `meet`

\#\# meet
- одна из переменных Undef - возвращаем другую
- обе чем-то проаннотированы - вовзращаем максимум

\#\# annotateConj
8. на данном этапе цель - это либо унификация, либо инвок; разберём обработку каждого из случаев отдельно

\#\#\# Унификация
- на термах вызываем `meetTerm`

\#\# meetTerm
- слева undef-переменная - получаем максимальную анноцию правого терма (вызываем `maxAnn`)
- слева аннотированная переменная - увеличим её значение на 1 и проставим везде вместо всех Undef в правом терме (используем функцию `replaceUndef` - она ругается на нарушение монотонности, если у внутри терма нашлась переменная, аннотация которой оказалась больше той, на которую хотим заменить)
- слева и справа кторы - проверяем, что их именна и кол-во аргументов совпадают, затем делаем zip аргументов и вызываем `meetTerm` на каждой паре аргументов
- оставшиеся случаи обрабатываются вызовом `meetTerm` на аргументах в обратном порядке; в конце восстанавливается исходный порядок

\#\# maxAnn
- переменная - очевидно
- конструктор - если есть хотя бы 1 внутренний Undef терм, вернём Undef, иначе вернём максимум из аннотаций

\#\#\# Инвоки
- существует 3 случая:
1. все термы Undef
  - ничего не делаем (будем ждать следущую итерацию, когда о термах станет известно хоть что-то)
2. такая цель уже есть в стеке (проверяем по имени и маске аннотаций термов - список списков, в котором n-ый список содержит номера переменных, инициализируемых в n-ый момент времени)
  - доопределяем Undef-термы как максимальная аннотация оставшихся термов + 1
  - добавляем в стек инфу о новом направлении (ВАЖНО: в качестве цели здесь кладётся undefined - может вылезти боком), при этом происходит сравнение масками с инфой об уже существующих направлениях: оставляется то направление, которое даёт больше информации о времени инициализации термов (пример: пусть есть маски [[2], [0, 1]] и [[2], [1], [0]]; они не противоречат друг другу и вторая даёт больше информации, поэтому её направление "затрёт" в стеке направление первой).
3. цели в списке не оказалось
  - получаем def по имени (из gamma)
  - по def получаем без фрешей, переименнованную, нормализованную, первично проинициализированную (инфой об аннотациях термов при вызове) цель, список ПЕРЕИМЕННОВЫННЫХ названий ЕЁ входных переменных, а также обновляем стек, складывая туда текущую маску и цель
  - аннотируем полученную цель, вызывая `annotateInternal` - получаем новую цель и новый стек
  - из цели получаем аннотации её аргументов и переносим эти аннотации на термы при инвоке - обновляем инвок
  - в уже изменённый стек по маске изменённых на прошлом шаге термов добавляем полученную цель


Вот поэтому считаем, что это работает. Вот тут семантика для \miniKanren~\cite{rozplokhas2019certified}.

\section{Заключение}\label{conclusion}

Таким образом, мы разработали анализ времени связывания для \miniKanren, а также доказали, что он работает. Основным его узким местом является случай вызова нескольких отношений на переменных, которые используются только в этих вызовах - в этом случае приходиться перебирать все возможные сочетания направлений трансляции этих отношений, что может быть довольно долго или давать неправильный ответ. На текущий момент вопрос о способе обработки такого рода случаев остаётся открытым.

Так же в дальнейшем будет продолжена работа над транслятором в функциональный язык - анализ времени связывания является ядром этого транслятора. По проаннотированной программе предстоит получить объявления в корректном порядке, а также продумать и реализовать корректную трансляцию остальных типов целей: дизъюнкции, конъюнкции.

\section*{Acknowledgment}

Выражаем благодарность Дмитрию Юрьевичу Булычеву и Даниилу Андреевичу Березуну за плодотворные дискуссии и конструктивную критику.

\bibliographystyle{IEEEtran.bst}
\bibliography{IEEEbib.bib}
\end{document}

