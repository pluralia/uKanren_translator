\subsection{Корректность алгоритма}

Алгоритм аннотирования, представленный в работе, способен аннотировать только нормализованные программы на \miniKanren{}.
Однако, любую программу на \miniKanren{} можно привести в нормальную форму описанными выше методами.
Таким образом, доказав корректность аннотирования нормализованных программ, мы докажем и корректность ненормализованных.

Алгоритм представляет собой адаптацию алгоритм анализа времени связывания для \miniKanren{}.
Для доказательства корректности необходимо показать его терминируемость и согласованность, что и сделано в последующих подчастях.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Терминируемость}

Алгоритм терминируется, так как повторное аннотирование отношений не производится.
Имеющиеся в стеке вызовов отношения не аннотируются снова, а в каждом отношении используется конечное количество уникальных переменных.
Это значит, что каждому отношению можно сопоставить конечное количество уникальных аннотаций.

Существование нескольких вызовов в одном дизъюнке приводит к необходимости применять алгоритм аннотирования ко всем возможным версиям дизъюнкта, каждая их которых отличается очередной перестановкой вызовов.
Терминируемость в этом случае следует из двух фактов:
\begin{itermize}
    \item Количество перестановок вызовов конечно и, значит, конечно количество версий дизъюнкта;
    \item Aлгоритм аннотирования терминируется (доказано выше).
\end{itermize}

Добавление генерации также не повлияет на терминируемость несмотря на итеративность процесса.
Количество переменных, оставшихся в случае неуспешного аннотироавния помеченными $Undef$, конечно для всего стека вызовов, так как конечно количество переменных в любом отношении, а, значит, и в стеке вызовов.
На каждой итерации генерации происходит добавление хотя бы одной генерации хотя бы в одно определение со стека вызовов.

Терминируемость доказана.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Согласованность}

В анализе времени связывания под согласованностью понимается зависимость статических данных только от статических: статические данные не могут определяться динамическими.

Вычисление дизъюнктов в \miniKanren{} происходит независимо, значит, и аннотировать их можно независимо.
Как следствие, ``проаннотировать тело отношения'' означает ``проаннотировать несколько дизъюнктов''.
Показав корректность аннотирования одного дизъюнкта, покажем корректность аннотирования всего тела.

Каждый дизъюнкт --- это конъюнкция вызовов и унификаций.
Вычисление конъюнктов в \miniKanren{} происходит одновременно: значение полученное в одном конъюнкте, мгновенно становится известно в другом.
Для аннотирования это означает, если стала известна аннотация целевой переменной в одном конъюнкте, она мгновенно становится известна во всех конъюнктах, в которые эта переменная входит.
Именно так и происходит в алгоритме: дизъюнкты аннотируются независимо, а аннотация переменной, ставшая известной в одном конъюнкте, распространяется на все вхождения этой переменной в другие конъюнкты.

Введём понятие зависимости одной переменной от другой в рамках предложенного алгоритма.
Понятия отношения и унификации "равноправны", но при выборе конкретного направления вычисления значения переменных множества $X$ неизбежно становятся известны раньше значений переменных множества $Y$.
В этом случае будем говорить, что переменные Y \emph{зависят} от переменных X.

Пример: зависимость для унификаций.
Пусть есть два конъюнкта: $x \equiv y$ и $y \equiv 7$.
Во втором конъюнкте $7$ --- константа, поэтому мы можем проунифицировать $y$ и сказать, что $y = 7$.
В этот же момент мы узнаем в первом конъюнкте, что $y$ стала известна и можем превратить унификацию в равенство $x = y$. Это и назовём зависимостью $x$ от $y$.

Пример: зависимость для вызовов отношений.
Пусть есть вызов отношения $append^o~x~y~z$, где мы уже знаем из других конъюнктов значение $z$.
В этом случае алгоритм посчитает, что этот вызов $append^o$ происходит в обратном направлении и переменные $x$ и $y$ являются выходными.
В этом случае можно говорить о зависимости $x$ и $y$ от $z$: $(x,~y)~=~append^o~z$ (в случае недетерминированной семантики $apppend^o$ корректнее говорить о $[(x,~y)]~=~append^o~z$).

Введём инвариант, отражающий идею согласованности.
Доказав его выполнение на любом шаге алгоритма, мы докажем его корректность.

\emph{Инвариант:
\begin{itemize}
    \item В любой момент времени переменная может быть не проаннотирована (иметь аннотацию $Undef$);
    \item Если переменная проаннотирована числом, то существует хотя бы один конъюнкт, в котором все переменные, от которых она зависит, проаннотированы строго меньшими числами;
\end{itemize}
}

Рассмотрим алгоритм ещё раз, чтобы убедиться в выполнении инварианта.
В начальный момент времени числовую аннотацию $0$ имеют только входные переменные.
Остальные переменные проаннотированы $Undef$.

Конъюнкты отсортированы: вызовы следуют за унификациями.
Последовательно обходим все унификации.
К каждой применяется алгоритм аннотирования унификаций, в точности выполняющий инвариант.
$Undef$-аннотация целевой переменной заменяется всегда на строго большее значение, чем значение аннотации любой переменной, от которой целевая переменная зависит.
После аннотирования каждого конъюнкта информация об аннотациях его переменных распространяется на все оставшиеся конъюнкты.
Следующий для аннотирования конъюнкт обладает релевантными аннотациями.

При таком подходе к моменту необходимости аннотировать первый вызов отношения мы можем быть уверены, что в текущем вызове известны все аннотации переменных, которые можно было получить из унификаций.
Все другие --- только из последующих вызовов отношений.
Тем самым, мы знаем направление первого вызова.
При наличии нескольких вызовов их порядок влияет на аннотирование.
Наилучший порядок, позволяющий получить проаннотированное отношение, можно найти только опытным путём --- перебрав все перестановки вызовов.
Поэтому, без ограничения общности можно считать, что первый вызов выбран верно.
Если аннотирование при этом закончится неудачей, запустится аннотирование того же дизъюнкта с другим порядком вызовов.
Важно заметить, что, в случае неуспеха аннотирования стек вызовов будет содержать переменные с $Undef$ аннотациями --- это является частью инварианта.

Вернёмся к аннотированию вызова.
Алгоритм аннотации аргументов вызова в точности соблюдает инвариант.
Каждое вызываемое в конкретном направлении отношение добавляется в стек, если оно там отсутствовало, и инициализируется так, что его входные переменные имеют аннотацию $0$.
Это позволяет рассматривать аннотацию тела вызываемого отношения независимо от причин аннотирования: является ли аннотируемая цель целью программы или телом вызываемого отношения.

Тем самым согласованность доказана.