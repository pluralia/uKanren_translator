\subsection{Система тестирования}

Данная глава описывает способ тестирования разработанного алгоритма трансляции.
Так как задачи формального доказательства сохранения семантики при трансляции не стояло, мы проверили правильность его работы на тестах. 
Для этого было реализован модуль тестирования, принимающий на вход программу на конкретном синтаксисе языка \miniKanren{}, производящий синтаксический анализ, транслирующий программу в заданном направлении в абстрактный синтаксис подмножества языка \haskell{} и дальше печатающий результат в конкретный синтаксис языка \haskell{}.
По завершении производится запуск транслированной программы и сравнение результатов с результатами работы исходной программы \miniKanren{} в выбранном направлении. 

В этой главе будет рассказано про компоненты тестирующей системы и множество тестовых программ. 
Также будет продемонстрирована способность транслятора улучшать производительность на примере отношения сортировки-генерации перестановок. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Синтаксический анализатор конкретного синтаксиса \miniKanren{}}

\miniKanren{} --- встраиваемый язык и это одно из его преимуществ, поэтому при разработке конкретного синтаксиса не стояло цели создать идеальный.
Цель его создания --- удобство тестирования.
Была создана соответствующая грамматика (см. рисунок~\ref{mk:grammar}), и с её использованием написан синтаксический анализатор на языке.

\begin{figure}[h!]
  \begin{center}
  \begin{minipage}{0.35\textwidth}
  \begin{lstlisting}[language=Haskell, frame=single, numbers=left,numberstyle=\small, firstnumber=187, escapechar=|]
  $::$ $append^o$ x y xy = conde |\label{line:ex1}|
    ($x$ === [] /\ $xy$ === $y$)
    ([$h$ $t$ $r$: 
        $x$ === $h$ $\%$ $t$ /\
        $xy$ === $h$ $\%$ $r$ /\
        {$append^o$ $t$ $y$ $r$}])     
  \end{lstlisting}
  \end{minipage}
  \end{center}
  \caption{Пример конкретного синтаксиса \miniKanren{}}
  \label{lst:ex}
\end{figure}

Пример конкретного синтаксиса приведён на рисунке~\ref{lst:ex}.
В строке~\ref{line:ex1} присутствует слово $conde$ --- оно является синтаксическим ``сахаром'' для дизъюнкции нескольких конъюнктов.

\begin{figure}[h!]
  \begin{center}
    \begin{boxedminipage}{\linewidth}
    \begin{grammar}
    <program> ::= <def>* <goal>
    
    <term> ::= <ident> | `<' <ident> `:' <term>* `>'
    
    <def> ::= `::' <ident> <ident>* `=' <goal>
    
    <goal> ::= <disj> | <fresh> | <invoke>
    
    <fresh> ::= `[' <ident>+ `:' <goal> `]'
    
    <invoke> ::= `{' <ident> <term>* `}'
    
    <disj> ::= <conj> (`\\/' <conj>)*
    
    <conj> ::= <pat> (`/\\' <pat>)*
    
    <pat> ::= <term> `===' <term> | <fin>
    
    <fin> ::= <fresh> | `(' <disj> `)'
    \end{grammar}
    \end{boxedminipage}
  \end{center}
  \caption{Грамматика языка \miniKanren{}}
  \label{mk:grammar}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Транслятор абстрактного синтаксиса функционального языка в конкретный}

Алгоритм трансляции абстрактного синтаксиса функционального языка в конкретный тривиален.
Он представляет собой последовательный обход всех конструкций абстрактного синтаксиса функционального языка и печать их форме, соответствующей конкретному синтаксису \haskell{}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Система тестирования}

Для тестирования была создана база программ на \miniKanren{}, покрывающая все пунты классификации (см. раздел~\ref{lab:classif}).
Само тестирование состоит из следующих шагов:
\begin{itemize}
    \item запуск синтаксического анализатора на программе в конкретном синтаксисе \miniKanren{};
    \item трансляция в абстрактный функциональный синтаксис для всех возможных направлений;
    \item трансляция в \haskell{};
    \item запуск $unit$-тестов на транслированной \haskell{}-программе с целью проверить, что полученная программа обладает желаемым поведением.
\end{itemize}

По результатам $unit$-тестирования можно утверждать, что предложенный алгоритм трансляции работает в ожидаемом режиме для всех классов программ на \miniKanren{} для всех направлений.
Под ``ожидаемым режимом'' подразумевается соответствие выполнения транслированной программы выполнению исходной программы на \miniKanren{} в целевом направлении.
Например, ситуация, когда транслированная на \haskell{} программа перечислила все результаты, но не завершается, может быть естественной, если такое же поведение свойственно вычислению транслируемого отношения на \miniKanren{} в целевом направлении.

Исходный код $unit$-тестов и результаты тестирования можно найти в репозитории проекта~\footnote{Система тестирования транслятора: ~\url{https://github.com/Pluralia/uKanren_translator/tree/master/test}, дата последнего доступа: 20.05.2020.}, автор принимал участие под учётной записью \emph{Pluralia}.